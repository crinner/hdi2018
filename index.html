<!doctype html>

<!-- --------------------------------------------------- -->
<!-- CODG 136, Winter 2020, Assignment 2 by Claus RINNER -->
<!-- This file was generated by QGIS 3.4 plugin qgis2web and modified using two other projects: -->
<!--  * Leaflet tutorial "Interactive Choropleth Map" at https://leafletjs.com/examples/choropleth/ -->
<!--  * "Leaflet Swipe between OpenCycleMap and Stamen Watercolor" at http://bl.ocks.org/wboykinm/b90873f4015fd8a8759e -->
<!-- --------------------------------------------------- -->

<html lang="en">

<!-- header mostly unchanged from QGIS export -->

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <link rel="stylesheet" href="css/leaflet.css">
        <link rel="stylesheet" href="css/qgis2web.css"><link rel="stylesheet" href="css/fontawesome-all.min.css">

        <style>

/* modified map div size (reduced height to fit other page elements, i.e. text and swipe control) */
        #map {
            width: 100%;
            height: 480px;
        }

/* width of swipe control to be the same as map width */
        #swipe {
            width:100%;
        }

        </style>

<!-- new HTML page title -->
        <title>CODG 136 Assignment 2</title>
    </head>

<!-- Page body from QGIS Leaflet export includes all layer styles and popup contents -->
<!-- The QGIS OpenLayers export puts this information in separate JS files -->
<!-- (better organized), but I find it easier for learning to have it all in one place -->
    <body>

<!-- page header, usage instructions, swipe slider, and map canvas  -->
        <h2 style="font-family: Arial">Human Development 2008-2018</h2>

        <div>The United Nations are tracking the progress of humanity over time. <b>Zoom</b> and <b>pan</b> the map, or <b>click on a country</b> to see its name and Human Development Index (HDI) scores. Use the <b>swipe</b> to compare 2018 (swipe to the right) with 2008 (swipe to the left); once the swipe is activated, you can also use the arrow keys to flip between the two years.</div>

        <input id='swipe' class='range' type='range' min='0.0' max='1.0' value='0.9' step='any' />

        <div id="map"></div>

        <hr style="height: 1px">

        <div><small>Author: Claus Rinner @RyersonGeo</small></div>
        <div><small>Data source: United Nations Development Programme, <a href="http://hdr.undp.org/en/data" target=_blank>http://hdr.undp.org/en/data</a></small></div>

<!-- default scripts exported from QGIS -->
        <script src="js/qgis2web_expressions.js"></script>
        <script src="js/leaflet.js"></script>
        <script src="js/multi-style-layer.js"></script>
        <script src="js/leaflet.rotatedMarker.js"></script>
        <script src="js/leaflet.pattern.js"></script>
        <script src="js/leaflet-hash.js"></script>
        <script src="js/Autolinker.min.js"></script>
        <script src="js/rbush.min.js"></script>
        <script src="js/labelgun.min.js"></script>
        <script src="js/labels.js"></script>
        <script src="data/NoData_0.js"></script>
        <script src="data/HDI2008_1.js"></script>
        <script src="data/HDI2018_2.js"></script>

<!-- BEGINNING OF MAIN SCRIPT FOR THIS PROJECT -->
        <script>

// Creation of Leaflet map object
        var map = L.map('map', {
            zoomControl:true, maxZoom:18, minZoom:0
        })

// This is from a Leaflet plugin included above; if I understand correctly, 
// It tracks the current map view (zoom and extent) through the browser URL for sharing 
        var hash = new L.Hash(map);

// Default attribution generated by qgis2web 
        map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com" target=_blank>Leaflet</a> &middot; <a href="https://qgis.org" target=_blank>QGIS</a>');

// Set initial map extent? 
        var bounds_group = new L.featureGroup([]);
        function setBounds() {
            if (bounds_group.getLayers().length) {
                map.fitBounds(bounds_group.getBounds());
            }
        }

/* BEGINNING OF LAYER DEFINITIONS */

// Definition of common layer popup contents (simplified from separate popup defs from QGIS export)
        function pop_NameHDI(feature, layer) {
            var popupContent = '<table>\
                    <tr>\
                        <th scope="row">Name</th>\
                        <td>' + (feature.properties['NAME'] !== null ? Autolinker.link(feature.properties['NAME'].toLocaleString(), {truncate: {length: 30, location: 'smart'}}) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">HDI 2008</th>\
                        <td>' + (feature.properties['HDI_2008'] !== null ? Autolinker.link(feature.properties['HDI_2008'].toLocaleString(), {truncate: {length: 30, location: 'smart'}}) : '') + '</td>\
                    </tr>\
                    <tr>\
                        <th scope="row">HDI 2018</th>\
                        <td>' + (feature.properties['HDI_2018'] !== null ? Autolinker.link(feature.properties['HDI_2018'].toLocaleString(), {truncate: {length: 30, location: 'smart'}}) : '') + '</td>\
                    </tr>\
                </table>';
            layer.bindPopup(popupContent, {maxHeight: 200});
        }

// Definition of no-data layer fill pattern (hatch texture) 
        var pattern_NoData_0_0 = new L.StripePattern({
            weight: 0.3,
            spaceWeight: 2.0,
            color: '#000000',
            opacity: 1.0,
            spaceOpacity: 0,
            angle: 315
        });
        pattern_NoData_0_0.addTo(map);

// Definition of layer style/symbol including use of the above defined fill pattern 
        function style_NoData_0_0() {
            return {
                pane: 'pane_NoData_0',
                stroke: false,
                fillOpacity: 1,
                fillPattern: pattern_NoData_0_0,
                interactive: true,
            }
        }

// Definition of another style/symbol for the same layer (no data); not sure what this is needed for 
        function style_NoData_0_1() {
            return {
                pane: 'pane_NoData_0',
                opacity: 1,
                color: 'rgba(0,0,0,1.0)',
                dashArray: '',
                lineCap: 'square',
                lineJoin: 'bevel',
                weight: 2.0,
                fillOpacity: 0,
                interactive: true,
            }
        }

// Create a pane (visual layer) within the map object, place at depth level 400 
        map.createPane('pane_NoData_0');
        map.getPane('pane_NoData_0').style.zIndex = 400;
        map.getPane('pane_NoData_0').style['mix-blend-mode'] = 'normal';

// Create the actual data layer from exported geoJSON data 
// The file "data/NoData_0.js" referenced above defines the variable "json_NoData_0" 
        var layer_NoData_0 = new L.geoJson.multiStyle(json_NoData_0, {
            attribution: '',
            interactive: true,
            dataVar: 'json_NoData_0',
            layerName: 'layer_NoData_0',
            pane: 'pane_NoData_0',
            onEachFeature: pop_NameHDI,
            styles: [style_NoData_0_0,style_NoData_0_1,]
        });

// Add layer to map and adjust extent boundaries 
        bounds_group.addLayer(layer_NoData_0);
        map.addLayer(layer_NoData_0);

// 
// Definition of next layer's style/symbol: choropleth using pretty breaks from QGIS. 
// This was simplified by making only the fillColor property dependent on the feature, 
// not the entire style as was the case in the qgis2web export (see below for comparison). 
// 
        function style_HDI2008_1_0(feature) {
            return {
                pane: 'pane_HDI2008_1',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: fillColor_HDI2008_1_0(feature),
                interactive: true,
            }
        }

        function fillColor_HDI2008_1_0(feature) {
            if (feature.properties['HDI_2008'] >= 0.304000 && feature.properties['HDI_2008'] <= 0.400000 ) {
                return 'rgba(208,28,139,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.400000 && feature.properties['HDI_2008'] <= 0.500000 ) {
                return 'rgba(230,131,192,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.500000 && feature.properties['HDI_2008'] <= 0.600000 ) {
                return 'rgba(243,204,228,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.600000 && feature.properties['HDI_2008'] <= 0.700000 ) {
                return 'rgba(247,247,247,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.700000 && feature.properties['HDI_2008'] <= 0.800000 ) {
                return 'rgba(205,233,172,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.800000 && feature.properties['HDI_2008'] <= 0.900000 ) {
                return 'rgba(148,208,102,1.0)'
            } else if (feature.properties['HDI_2008'] >= 0.900000 && feature.properties['HDI_2008'] <= 0.938000 ) {
                return 'rgba(77,172,38,1.0)'
            } else return 'rgba(255,255,255,0.0)' // transparent, which seems to overwrite the opacity property :) 
        }

// Create a pane (visual layer) within the map object, place at higher level 401 
        map.createPane('pane_HDI2008_1');
        map.getPane('pane_HDI2008_1').style.zIndex = 401;
        map.getPane('pane_HDI2008_1').style['mix-blend-mode'] = 'normal';

// Create the actual data layer from exported geoJSON data 
// The GeoJSON (JS) file referenced above defines the variable (Geo)JSON object referenced here" 
        var layer_HDI2008_1 = new L.geoJson(json_HDI2008_1, {
            attribution: '',
            interactive: true,
            dataVar: 'json_HDI2008_1',
            layerName: 'layer_HDI2008_1',
            pane: 'pane_HDI2008_1',
            onEachFeature: pop_NameHDI,
            style: style_HDI2008_1_0,
        });

// Add layer to map and adjust extent boundaries 
        bounds_group.addLayer(layer_HDI2008_1);
        map.addLayer(layer_HDI2008_1);

// 
// Definition of next layer's style/symbol: choropleth using pretty breaks from QGIS 
// This should be simplified as shown above
// Also added a final 'else' statement for no-data countries to be transparent
// 
        function style_HDI2018_2_0(feature) {
            if (feature.properties['HDI_2018'] >= 0.377000 && feature.properties['HDI_2018'] <= 0.400000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(208,28,139,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.400000 && feature.properties['HDI_2018'] <= 0.500000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(230,131,192,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.500000 && feature.properties['HDI_2018'] <= 0.600000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(243,204,228,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.600000 && feature.properties['HDI_2018'] <= 0.700000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(247,247,247,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.700000 && feature.properties['HDI_2018'] <= 0.800000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(205,233,172,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.800000 && feature.properties['HDI_2018'] <= 0.900000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(148,208,102,1.0)',
                interactive: true,
            }
            }
            if (feature.properties['HDI_2018'] >= 0.900000 && feature.properties['HDI_2018'] <= 0.954000 ) {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(77,172,38,1.0)',
                interactive: true,
            }
            } else {
                return {
                pane: 'pane_HDI2018_2',
                opacity: 1,
                color: 'rgba(35,35,35,1.0)',
                dashArray: '',
                lineCap: 'butt',
                lineJoin: 'miter',
                weight: 1.0, 
                fill: true,
                fillOpacity: 1,
                fillColor: 'rgba(255,255,255,0.0)',
                interactive: true,
            }
            }
        }

// Create a pane (visual layer) within the map object, place at highest level 402
// This pane is being manipulated by the swipe control below
        map.createPane('pane_HDI2018_2');
        map.getPane('pane_HDI2018_2').style.zIndex = 402;
        map.getPane('pane_HDI2018_2').style['mix-blend-mode'] = 'normal';

// Create the actual data layer from exported geoJSON data
// The GeoJSON (JS) file referenced above defines the variable (Geo)JSON object referenced here"
        var layer_HDI2018_2 = new L.geoJson(json_HDI2018_2, {
            attribution: '',
            interactive: true,
            dataVar: 'json_HDI2018_2',
            layerName: 'layer_HDI2018_2',
            pane: 'pane_HDI2018_2',
            onEachFeature: pop_NameHDI,
            style: style_HDI2018_2_0,
        });

// Add layer to map and adjust extent boundaries
        bounds_group.addLayer(layer_HDI2018_2);
        map.addLayer(layer_HDI2018_2);

/* END OF LAYER DEFINITIONS */

// No base maps used in this project
        var baseMaps = {};

// 
// Layer controls consisting of layer name (checkbox auomatically generated for each layer I guess?)
// Followed by rows consisting of legend symbols (small coloured squares from PNG files) and value ranges
// 
// REPLACED BELOW

/*
        L.control.layers(baseMaps,{'HDI 2018<br /><table><tr><td style="text-align: center;"><img src="legend/HDI2018_2_03770040000.png" /></td><td>0.3770 - 0.4000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_04000050001.png" /></td><td>0.4000 - 0.5000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_05000060002.png" /></td><td>0.5000 - 0.6000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_06000070003.png" /></td><td>0.6000 - 0.7000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_07000080004.png" /></td><td>0.7000 - 0.8000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_08000090005.png" /></td><td>0.8000 - 0.9000</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2018_2_09000095406.png" /></td><td>0.9000 - 0.9540</td></tr></table>': layer_HDI2018_2,'HDI 2008<br /><table><tr><td style="text-align: center;"><img src="legend/HDI2008_1_030404000.png" /></td><td>0.304 - 0.400</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_040005001.png" /></td><td>0.400 - 0.500</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_050006002.png" /></td><td>0.500 - 0.600</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_060007003.png" /></td><td>0.600 - 0.700</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_070008004.png" /></td><td>0.700 - 0.800</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_080009005.png" /></td><td>0.800 - 0.900</td></tr><tr><td style="text-align: center;"><img src="legend/HDI2008_1_090009386.png" /></td><td>0.900 - 0.938</td></tr></table>': layer_HDI2008_1,'<img src="legend/NoData_0.png" /> No Data': layer_NoData_0,},{collapsed:false}).addTo(map);
*/

// Simplified non-interactive legend, modified from Leaflet choropleth tutorial
        var legend = L.control({position: 'bottomright'});

        legend.onAdd = function (map) {

            var div = L.DomUtil.create('div', 'info legend'),
                grades = [0.3, 0.4000, 0.5000, 0.6000, 0.7000, 0.8000, 0.9000, 1.0],
                images = ["HDI2008_1_030404000.png", "HDI2008_1_040005001.png", "HDI2008_1_050006002.png", "HDI2008_1_060007003.png", "HDI2008_1_070008004.png", "HDI2008_1_080009005.png", "HDI2018_2_09000095406.png"];

            // loop through our density intervals and generate a label with a colored square for each interval
            for (var i = 0; i < images.length; i++) {
                div.innerHTML +=
                    '<img src="legend/' + images[i] + '" /> ' +
                    grades[i] + ' &ndash; ' + grades[i + 1] + '<br>';
            }

            return div;
        };

        legend.addTo(map);

// Reset map to the extent of all added layers
        setBounds();

// 
// The following code is adapted from http://bl.ocks.org/wboykinm/b90873f4015fd8a8759e
// 

// Get a handle on the swipe/range input widget
          var swipe = document.getElementById('swipe');

// Clip the overlaying map (2018 HDI) to the left side of the map canvas in proportion to the swipe value
          function clip() {
            var nw = map.containerPointToLayerPoint([0, 0]),
                se = map.containerPointToLayerPoint(map.getSize()),
                clipX = nw.x + (se.x - nw.x) * swipe.value;

// The following code from source, which used getContainer function, did not work; 
// fortunately, we already have handles for the map panes
//    layer_HDI2018_2.getContainer().style.clip = 'rect(' + [nw.y, clipX, se.y, nw.x].join('px,') + 'px)';
            map.getPane('pane_HDI2018_2').style.clip = 'rect(' + [nw.y, clipX, se.y, nw.x].join('px,') + 'px)';
          }

// Not sure what exactly is going on here - something to do with setting the event handlers for map and swipe
          swipe['oninput' in swipe ? 'oninput' : 'onchange'] = clip;
          map.on('move', clip);

// Center the map and set to second-lowest zoom level (so that it looks ok in both mobile and desktop)
// Ideally the initial zoom should be made dependent on device size and orientation
          map.setView([20, 0], 2);

// Run clip once at start based on swipe value (centered at 50% showing left half of top layer)
          clip();

        </script>

<!-- END OF MAIN SCRIPT FOR THIS PROJECT -->

<!-- 
    Possible improvements (for Assignment 3?): 
    global map projection, 
    appearance for mobile (initial zoom), 
    faster loading (placement of scripts?), 
    country search/selection, 
    info on mouse-over
 -->

    </body>

</html>
